/*
 * Copyright 2001-2008 Artima, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.scalatest.fun

import org.scalatest.Suite
import org.scalacheck.Arbitrary
import org.scalacheck.Shrink
import org.scalacheck.Arg
import org.scalacheck.Prop
import org.scalacheck.Test

/**
 * Trait that contains several &#8220;check&#8221; methods that can be used to perform ScalaCheck property checks
 * that will be reported as a ScalaTest test failure if ScalaCheck finds a test case for which the property doesn't hold.
 * To use ScalaCheck, you specify properties and, in some cases, generators that generate test data. You need not always
 * create generators because ScalaCheck provides many default generators for you, which can be used in many situations.
 * ScalaCheck will use the generators to generate test data and with that data run tests that check that the property holds.
 * Property-based tests can, therefore, give you a lot more testing for a lot less code than asertion-based tests.
 * Here's an example of using ScalaCheck from a ScalaTest suite:
 * <pre>
 * import org.scalatest.Suite
 * import org.scalatest.fun.Checkers
 * import org.scalacheck.Arbitrary._
 * import org.scalacheck.Prop._
 *
 * class MySuite extends Suite with Checkers {
 *   def testConcat() {
 *     check((a: List[Int], b: List[Int]) => a.size + b.size == (a ::: b).size)
 *   }
 * }
 * </pre>
 * <p>
 * The <code>check</code> method, defined in <code>Checkers</code>, makes it easy to write property-based tests inside
 * ScalaTest, JUnit, and TestNG test suites. This example specifies a property that <code>List</code>'s <code>:::</code> method
 * should obey. ScalaCheck properties are expressed as function values that take as parameters the required
 * test data, which will be generated by ScalaCheck. In this case, the test data is composed of lists of integer named <code>a</code> and <code>b</code>.
 * Inside the body of the function, you see:
 * </p>
 * <pre>
 * a.size + b.size == (a ::: b).size
 * </pre>
 * <p>
 * The property in this case is a <code>Boolean</code> expression that will yield true if the size of the concatenated list is equal
 * to the size of each individual list added together. With this small amount
 * of code, ScalaCheck will generate possibly hundreds of values for <code>a</code> and <code>b</code> and test each one, looking for
 * a value for which the property doesn't hold. If the property holds true for every value ScalaCheck tries,
 * <code>checkProperty</code> returns normally. Otherwise, <code>checkProperty</code> will complete abruptly with an <code>AssertionError</code> that
 * contains information including the value that caused the failure.
 * </p>
 *
 * <p>
 * For more information on using ScalaCheck properties, see the documentation for ScalaCheck, which is available
 * from <a href="http://code.google.com/p/scalacheck/">http://code.google.com/p/scalacheck/</a>.
 * </p>
 *
 * <p>
 * To execute a suite that mixes in <code>Checkers</code> with ScalaTest's <code>Runner</code>, you must include ScalaCheck's jar file on the class path or runpath.
 * This version of <code>Checkers</code> was tested with ScalaCheck version 1.1.1. This trait must
 * be mixed into a ScalaTest <code>Suite</code>, because its self type is <code>org.scalatest.Suite</code>.
 * </p>
 *
 * @author Bill Venners
 */
trait Checkers {

  this: Suite =>

  /**
   * Convert the passed 1-arg function into a property, and check it.
   *
   * @param f the function to be converted into a property and checked
   * @throws AssertionError if a test case is discovered for which the property doesn't hold.
   */
  def check[A1,P](f: A1 => P)
    (implicit
      p: P => Prop,
      a1: Arbitrary[A1], s1: Shrink[A1]
    ) {
    check(Prop.property(f)(p, a1, s1))
  }

  /**
   * Convert the passed 2-arg function into a property, and check it.
   *
   * @param f the function to be converted into a property and checked
   * @throws AssertionError if a test case is discovered for which the property doesn't hold.
   */
  def check[A1,A2,P](f: (A1,A2) => P)
    (implicit
      p: P => Prop,
      a1: Arbitrary[A1], s1: Shrink[A1],
      a2: Arbitrary[A2], s2: Shrink[A2]
    ) {
    check(Prop.property(f)(p, a1, s1, a2, s2))
  }

  /**
   * Convert the passed 3-arg function into a property, and check it.
   *
   * @param f the function to be converted into a property and checked
   * @throws AssertionError if a test case is discovered for which the property doesn't hold.
   */
  def check[A1,A2,A3,P](f: (A1,A2,A3) => P)
    (implicit
      p: P => Prop,
      a1: Arbitrary[A1], s1: Shrink[A1],
      a2: Arbitrary[A2], s2: Shrink[A2],
      a3: Arbitrary[A3], s3: Shrink[A3]
    ) {
    check(Prop.property(f)(p, a1, s1, a2, s2, a3, s3))
  }

  /**
   * Convert the passed 4-arg function into a property, and check it.
   *
   * @param f the function to be converted into a property and checked
   * @throws AssertionError if a test case is discovered for which the property doesn't hold.
   */
  def check[A1,A2,A3,A4,P](f: (A1,A2,A3,A4) => P)
    (implicit
      p: P => Prop,
      a1: Arbitrary[A1], s1: Shrink[A1],
      a2: Arbitrary[A2], s2: Shrink[A2],
      a3: Arbitrary[A3], s3: Shrink[A3],
      a4: Arbitrary[A4], s4: Shrink[A4]
    ) {
    check(Prop.property(f)(p, a1, s1, a2, s2, a3, s3, a4, s4))
  }

  /**
   * Convert the passed 5-arg function into a property, and check it.
   *
   * @param f the function to be converted into a property and checked
   * @throws AssertionError if a test case is discovered for which the property doesn't hold.
   */
  def check[A1,A2,A3,A4,A5,P](f: (A1,A2,A3,A4,A5) => P)
    (implicit
      p: P => Prop,
      a1: Arbitrary[A1], s1: Shrink[A1],
      a2: Arbitrary[A2], s2: Shrink[A2],
      a3: Arbitrary[A3], s3: Shrink[A3],
      a4: Arbitrary[A4], s4: Shrink[A4],
      a5: Arbitrary[A5], s5: Shrink[A5]
    ) {
    check(Prop.property(f)(p, a1, s1, a2, s2, a3, s3, a4, s4, a5, s5))
  }

  /**
   * Convert the passed 6-arg function into a property, and check it.
   *
   * @param f the function to be converted into a property and checked
   * @throws AssertionError if a test case is discovered for which the property doesn't hold.
   */
  def check[A1,A2,A3,A4,A5,A6,P](f: (A1,A2,A3,A4,A5,A6) => P)
    (implicit
      p: P => Prop,
      a1: Arbitrary[A1], s1: Shrink[A1],
      a2: Arbitrary[A2], s2: Shrink[A2],
      a3: Arbitrary[A3], s3: Shrink[A3],
      a4: Arbitrary[A4], s4: Shrink[A4],
      a5: Arbitrary[A5], s5: Shrink[A5],
      a6: Arbitrary[A6], s6: Shrink[A6]
    ) {
    check(Prop.property(f)(p, a1, s1, a2, s2, a3, s3, a4, s4, a5, s5, a6, s6))
  }

  /**
   * Check a property with the given testing parameters.
   *
   * @param p the property to check
   * @param prms the test parameters
   * @throws AssertionError if a test case is discovered for which the property doesn't hold.
   */
  def check(p: Prop, prms: Test.Params) {
    //val stats = Test.check(prms, p, (r,s,d) => ())
    val stats = Test.check(prms, p)
    val result = stats.result
    result match {
      case Test.Proved(args) => 
      case Test.Passed => 
      case _ => fail(prettyTestStats(stats))
    }
  }

  /**
   * Check a property.
   *
   * @param p the property to check
   * @throws AssertionError if a test case is discovered for which the property doesn't hold.
   */
  def check(p: Prop) {
    check(p, Test.defaultParams)
  }

  private def prettyTestStats(stats: Test.Stats) = stats.result match {
    case Test.Proved(args) =>
      "OK, proved property:                   \n" + prettyArgs(args)
    case Test.Passed =>
      "OK, passed " + stats.succeeded + " tests."
    case Test.Failed(args) =>
      "Falsified after "+stats.succeeded+" passed tests:\n"+prettyArgs(args)
    case Test.Exhausted =>
      "Gave up after only " + stats.succeeded + " passed tests. " +
      stats.discarded + " tests were discarded."
    case Test.PropException(args,e) =>
      "Exception \"" + e + "\" raised on property evaluation:\n" +
      prettyArgs(args)
    case Test.GenException(e) =>
      "Exception \"" + e + "\" raised on argument generation."
  }

  private def prettyArgs(args: List[Arg]) = {
    val strs = for((a,i) <- args.zipWithIndex) yield (
      "> " +
      (if(a.label == "") "ARG_" + i else a.label) +
      " = \"" + a.arg +
      (if(a.shrinks > 0) "\" (" + a.shrinks + " shrinks)" else "\"")
    )
    strs.mkString("\n")
  }
}
