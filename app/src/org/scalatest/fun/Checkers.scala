package org.scalatest.fun

import org.scalatest.Suite
import org.scalacheck.Arbitrary
import org.scalacheck.Arb
import org.scalacheck.Prop
import org.scalacheck.Test.Params
import org.scalacheck.Test
import org.scalacheck.Test._

/**
 * Trait that contains several &#8220;check&#8221; methods that can be used to perform ScalaCheck property checks
 * that will be reported as a ScalaTest test failure if ScalaCheck finds a test case for which the property doesn't hold.
 * To use ScalaCheck, you specify properties and, in some cases, generators that generate test data. You need not always
 * create generators because ScalaCheck provides many default generators for you, which can be used in many situations.
 * ScalaCheck will use the generators to generate test data and with that data run tests that check that the property holds.
 * Property-based tests can, therefore, give you a lot more testing for a lot less code than asertion-based tests.
 * Here's an example of using ScalaCheck from a ScalaTest suite:
 * <pre>
 * import org.scalatest.Suite
 * import org.scalatest.props.Checkers
 * import org.scalacheck.Arbitrary._
 * import org.scalacheck.Prop._
 *
 * class MySuite extends Suite with Checkers {
 *   def testConcat() {
 *     check((a: List[Int], b: List[Int]) => a.size + b.size == (a ::: b).size)
 *   }
 * }
 * </pre>
 * <p>
 * The <code>check</code> method, defined in <code>Checkers</code>, makes it easy to write property-based tests inside
 * ScalaTest, JUnit, and TestNG test suites. This example specifies a property that <code>List</code>'s <code>:::</code> method
 * should obey. ScalaCheck properties are expressed as function values that take as parameters the required
 * test data, which will be generated by ScalaCheck. In this case, the test data is composed of lists of integer named <code>a</code> and <code>b</code>.
 * Inside the body of the function, you see:
 * </p>
 * <pre>
 * a.size + b.size == (a ::: b).size
 * </pre>
 * <p>
 * The property in this case is a <code>Boolean</code> expression that will yield true if the size of the concatenated list is equal
 * to the size of each individual list added together. With this small amount
 * of code, ScalaCheck will generate possibly hundreds of values for <code>a</code> and <code>b</code> and test each one, looking for
 * a value for which the property doesn't hold. If the property holds true for every value ScalaCheck tries,
 * <code>checkProperty</code> returns normally. Otherwise, <code>checkProperty</code> will complete abruptly with an <code>AssertionError</code> that
 * contains information including the value that caused the failure.
 * </p>
 *
 * <p>
 * For more information on using ScalaCheck properties, see the documentation for ScalaCheck, which is available
 * from <a href="http://code.google.com/p/scalacheck/">http://code.google.com/p/scalacheck/</a>.
 * </p>
 *
 * <p>
 * To execute a suite that mixes in <code>Checkers</code> with ScalaTest's <code>Runner</code>, you must include ScalaCheck's jar file on the class path or runpath.
 * This version of <code>Checkers</code> was tested with ScalaCheck version 1.1.1. This trait must
 * be mixed into a ScalaTest <code>Suite</code>, because its self type is <code>org.scalatest.Suite</code>.
 * </p>
 *
 * @author Bill Venners
 */
trait Checkers {

  this: Suite =>

  /**
   * Convert the passed 1-arg function into a property, and check it.
   *
   * @param f the function to be converted into a property and checked
   * @throws AssertionError if a test case is discovered for which the property doesn't hold.
   */
  def check[A1,P](f: A1 => P)
    (implicit
      p: P => Prop,
      a1: Arb[A1] => Arbitrary[A1]
    ) {
    check(Prop.property(f)(p, a1))
  }

  /**
   * Convert the passed 2-arg function into a property, and check it.
   *
   * @param f the function to be converted into a property and checked
   * @throws AssertionError if a test case is discovered for which the property doesn't hold.
   */
  def check[A1,A2,P](f: (A1,A2) => P)
    (implicit
      p: P => Prop,
      a1: Arb[A1] => Arbitrary[A1],
      a2: Arb[A2] => Arbitrary[A2]
    ) {
    check(Prop.property(f)(p, a1, a2))
  }

  /**
   * Convert the passed 3-arg function into a property, and check it.
   *
   * @param f the function to be converted into a property and checked
   * @throws AssertionError if a test case is discovered for which the property doesn't hold.
   */
  def check[A1,A2,A3,P](f: (A1,A2,A3) => P)
    (implicit
      p: P => Prop,
      a1: Arb[A1] => Arbitrary[A1],
      a2: Arb[A2] => Arbitrary[A2],
      a3: Arb[A3] => Arbitrary[A3]
    ) {
    check(Prop.property(f)(p, a1, a2, a3))
  }

  /**
   * Convert the passed 4-arg function into a property, and check it.
   *
   * @param f the function to be converted into a property and checked
   * @throws AssertionError if a test case is discovered for which the property doesn't hold.
   */
  def check[A1,A2,A3,A4,P](f: (A1,A2,A3,A4) => P)
    (implicit
      p: P => Prop,
      a1: Arb[A1] => Arbitrary[A1],
      a2: Arb[A2] => Arbitrary[A2],
      a3: Arb[A3] => Arbitrary[A3],
      a4: Arb[A4] => Arbitrary[A4]
    ) {
    check(Prop.property(f)(p, a1, a2, a3, a4))
  }

  /**
   * Convert the passed 5-arg function into a property, and check it.
   *
   * @param f the function to be converted into a property and checked
   * @throws AssertionError if a test case is discovered for which the property doesn't hold.
   */
  def check[A1,A2,A3,A4,A5,P](f: (A1,A2,A3,A4,A5) => P)
    (implicit
      p: P => Prop,
      a1: Arb[A1] => Arbitrary[A1],
      a2: Arb[A2] => Arbitrary[A2],
      a3: Arb[A3] => Arbitrary[A3],
      a4: Arb[A4] => Arbitrary[A4],
      a5: Arb[A5] => Arbitrary[A5]
    ) {
    check(Prop.property(f)(p, a1, a2, a3, a4, a5))
  }

  /**
   * Convert the passed 6-arg function into a property, and check it.
   *
   * @param f the function to be converted into a property and checked
   * @throws AssertionError if a test case is discovered for which the property doesn't hold.
   */
  def check[A1,A2,A3,A4,A5,A6,P](f: (A1,A2,A3,A4,A5,A6) => P)
    (implicit
      p: P => Prop,
      a1: Arb[A1] => Arbitrary[A1],
      a2: Arb[A2] => Arbitrary[A2],
      a3: Arb[A3] => Arbitrary[A3],
      a4: Arb[A4] => Arbitrary[A4],
      a5: Arb[A5] => Arbitrary[A5],
      a6: Arb[A6] => Arbitrary[A6]
    ) {
    check(Prop.property(f)(p, a1, a2, a3, a4, a5, a6))
  }

  /**
   * Check a property with the given testing parameters.
   *
   * @param p the property to check
   * @param prms the test parameters
   * @throws AssertionError if a test case is discovered for which the property doesn't hold.
   */
  def check(p: Prop, prms: Params) {
    val stats = Test.check(prms, p, (r,s,d) => ())
    val result = stats.result
    result match {
      case r: Passed => 
      case r: Failed => fail()
      case r: Exhausted => fail()
      case r: PropException => fail()
      case r: GenException => fail()
    }
    println("********" + result)
  }

  /**
   * Check a property.
   *
   * @param p the property to check
   * @throws AssertionError if a test case is discovered for which the property doesn't hold.
   */
  def check(p: Prop) {
    check(p, Test.defaultParams)
  }
}
