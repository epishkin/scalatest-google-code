Use filter in the run methods

drop recipe name from runner and runnerjframe

add the 'it should/must ""/describe a ""/describe it ""' style to Spec

Do the fixture package for Suite, FunSuite, and Spec

Make a GoodiesFixture trait for getting the goodies into a test

Do the OneInstancePerTest and ParallelTestExecution traits

Add BeforeAndAfterEach, BeforeAndAfterAll, AfterEach. Make BeforeAndAfter just an extension of BeforeAndAfterEach and BeforeAndAfterAll and deprecate it.
BeforeAndAfterAll will need to look for some object sent down in goodies from OneInstancePerTest, so it knows not to do it if it is an
"isolated test instance" or something. And then it will also have to turn off the distributor. This would mean that DistributedTestExecution
would not happen if there's an AfterAll right now. Later, what I could do is BeforeAndAfterAll wraps the distributor, if it is defined, in
an AfterAllDistributor. And that guy would wrap the suites that are put into it in a SuiteWrapper that forwards the run invocation but when
it completes (in a finally) it notifies an AfterAllActor. This react actor knows which notifications to wait for, and when they are all done, it
executes the after all method. So my theory is that since I'm using react, these actors won't hold up threads. But what tangled complexity we weave when
we first learn to parallelize.

Do WordSpec and FeatureSpec. WordSpec can use the same data structure as Spec, which would then give it the same kind of output.

Write tests for JUnitComfort Suite.
Document JUnitComfortSuite.

Add the "it" form to SharedTest.

Put an Option[Nothing] in the run methods as a placeholder for the OutErrTester kind of stuff. Whatever that object is
that's getting passed around. OutErrManager maybe. Wierd, could even provide overloaded versions. Wait, I could do that
anyway. Just add it at the end later, and make.., no because then it would have to be final.
OutputManager, OutputTester. Those seem nicer. Anyway, it is for another day.

Someone complained that it they configured the graphic reporter, that it should show that configuration by default not
just runs and failures. Not sure.

Do more testing on the FilterReporter config stuff.

Try sorting the GUI reports with the ordinal

I think I want to deprecate the use of -x for tags to exclude, to use it for XML Reporter. So in 0.9.6, -x should
still work, but so will some new one. And I'll warn folks that probably in 0.9.7, -x will start meaning xml reporter.

Refactor SuiteRerunner to just create a tools.SuiteRunner and call run on that. Maybe SuiteRunner should be in org.scalatest,
because it is also used by Distributor and will be used by SuiteRerunner.

add a RandomTestOrder trait

Change info in FunSuite to probably use an actor so multiple threads can fire infos. Oh and maybe you need to put the var that holds the current one in an atomic. Because only one thread should be writing to that.

Do the OneArgXXX traits

put goodies in ant task as well as properties for two releases, then drop properties
Change description of user-defined properties in Runner to "goodies". Do same thing includes --> tagsToInclude,
excludes --> tagsToExclude. Leave old one in for two releases.

Add the things for Property based testing displaying args nicely in the GUI (like empty strings should be "")

The eating error message problem. Make sure an exception message shows up in the GUI/Print output.

Oh, and must fix the problem of counting tests when using config params. RunStopped, RunCompleted, and RunAborted all take an optional Summary. When fired from Runner, SuiteRerunner, and TestRerunner, these are Nones. So maybe I enhance DispatchReporter to count these? To reset the count to zero when a RunCompleted, RunStopped, or RunAborted comes through? It would be counted by the actor thread. And if the summary field was a None, it would replace it with a Some that has these counts in it.

I'm not printing out the message in a formatted report, just the exception's detail message

Add more overloaded methods to Informer that take optional throwable, formatter, payload, etc.

Do an xml reporter and an html reporter

Ask folks about run versus execute
Ask folks about TestCase/Suite compatibility (check about testNames, because if that doesn't work it really is a non-starter)
Ask folks about the beforeAll and afterAll in BeforeAndAfter

a *** file-system separator separated runpath (platform-runpath)
b
c - concurrent execution (--concurrent)
d
e - standard error reporter (--stderr-reporter)
f - file reporter
g - graphical reporter
h *** HTML Reporter
i
j *** some way to run existing Java JUnit tests from command line
k
l
m - members only path
n - tags to include
o - standard out reporter
p - space-separated runpath
q
r - custom reporter
s - suite class name
t - testNG XML config file
u
v *** xml reporter (v for verbose!)
w - wildcard path
x - tags to exclude
y
z

D - goodie pair

For HTML reporter, can pick a style sheet? Could be -hC for Colorful, else get pretty one like cobertura

-w and -m could take an option "Q" for quick discovery that uses naming conventions. It would only load
classes whose .class file names end in Spec or Suite.

George list:

1. Update build.xml. Right now compile and test only builds and tests
ShouldMatchers. You have to run gencode by hand and then recompile and
test to get MustMatchers, because MustMatchers is generated from
ShouldMatchers. Please modify the ant file so default task builds all
(test builds and tests all, compile compiles all, including the
MustMatchers). Then add a qbuild and qcompile that skips the gencode
so I can do quicker builds. It takes 5 minutes to do a full build
without MustMatchers, so that's long enough. Also, if it will work,
can you make a clean target that doesn't delete the matcher tests,
because that's what takes forever to compile. Maybe a qclean?

2. Modify ant task
- Add goodies to the ant task (leaving in properties as "deprecated"
for two releases) I renamed properties to goodies because there are
two other things called properties in ScalaTest (HavePropertyMatchers
and ScalaCheck property checks). Also, one guy thought properties
specified that way should be Java system properties. Calling them
goodies should avoid that confusion as well.
- Add tagsToInclude to the ant task (leaving in includes as
"deprecated" for two releases), to bring ant task in line with new
name.
- Add tagsToExclude to the ant task (leaving in excludes as
"deprecated" for two releases), to bring ant task in line with new
name.
- Add a -a runpath command line option, (also in the ant task but I'm
not sure under what name). Idea is that -p takes a space-separated
runpath, which works fine except when people have spaces in their
paths. I want to keep -p as is, because you can specify jar files with
URLs in there, but also provide another way to specify the runpath -s,
that uses the traditional path separated by platform-specific
separator character. (On Unix, a :, on Windows, a;, etc.) Please
suggest a name for this, maybe platformRunpath or something.
- Create a JUnitWrapperSuite, which can wrap an existing set of JUnit
tests, probably written in Java, but already compiled to binary
- Recommend something to do with -j. What I'd like people to be able
to do is use -j to point ScalaTest's Runner to some existing JUnit
tests, and have it create the JUnitWrapperSuite necessary to run them
from within ScalaTest.
- The JUnit Ant task does some discovery. I think it relies on things
being named Test. I'd like to be able to tell people they can do the
exact same discovery of JUnit tests with ScalaTest's ant task as they
can with JUnit's ant task. That way it is a migration path forward.
They should be able to run those old JUnit tests with similar stuff in
the ScalaTest ant task that they now put in the JUnit ant task.
- Add a "quick" option for suite discovery. Suite discovery takes a
long time already for ScalaTest testing itself, because Scala
generates so many darn class files. We're opening every single one
looking for suites. I think if they add a Q to their -w or -m's, like
-wQ or -mQ, then that batch should be done based on naming convention.
ScalaTest will only even open class files that end in either "Spec" or
"Suite" looking for classes that extend org.scalatest.Suite. We could
add Test in there if people request it, but frankly these classes
represent suites of tests not single tests usually, so I'd like to try
and get them out of the JUnit habit of calling the classes XTest. Plus
it helps differentiate when discovering in packages that have mixed
JUnit tests and ScalaTest Suites, which would speed up both kinds of
discovery.

3. Surefire support.
- Maven uses something called SureFire to run tests. A fellow named
Jan has started some integration here. Once you get to this point, let
me know and I'll find out where Jan is at so you can see if you want
to start there. I don't know much about SureFire, but I think we need
to support Maven as well as Ant to get Maven people to use ScalaTest.

4. HTML and XML reporters
- Dianne is doing an HTML reporter, so when you get to this one, let
me know and I'll see where she's at. But one thing is we want a -h
command line param to run the HTML reporter, and also add this to the
ant task.
- Do an XML reporter that always prints out everything no matter what
it is configured with. Print out the ordinal and everything. The
reason is this can be used as an output during concurrent tests which
can be read in and then sorted to produce other output.

