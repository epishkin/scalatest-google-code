pass goodies down into before and after methods

Drop can from WordSpec. Go ahead and have WordSpec mix in ShouldVerb and MustVerb from the get go. Make sure
ShouldVerb and MustVerb also work from FlatSpec. If you want either or both matchers, they should
mix in just fine into either WordSpec or FlatSpec.

add description to FeatureSpec

pass goodies into RunStarting.

Add specific shared test support to FlatSpec. Drop the SharedTests and TestRegistartion traits.

Maybe add can back in to FlatSpec and WordSpec, via CanVerbs.

In OneInstancePerTest, override runNestedSuites and don't call super.runNestedSuites if testNames is defined.

drop recipe name from Runner and RunnerJFrame

Turn off tags in JUnitComfortSuite? At least until 0.9.8 when I turn on TagAnnotation?

Do the fixture and goodies packages for Suite, FunSuite, Spec, WordSpec, FlatSpec, and FeatureSpec.

Add back in Report and SpecReport. Put deprecated final execute methods in that forward as best they can to the regular one, though
perhaps I just need the final execute forms for the interpreter and the one public execute. Make a trait that can be mixed into
Reporter called TransitionalReporter, which has an apply method that forwards to the old methods, so people can bring existing reporters
up to date with a quick mix in. Or, consider whether I can just do that directly in Reporter itself. Oh, no, because then people's would
extensions would automatically work. No, that's OK. Just deprecate all the old testStarting, etc., methods.

Do the ParallelTestExecution trait. 

Write tests for JUnitComfort Suite.

Document JUnitComfortSuite.

Put an Option[Nothing] in the run methods as a placeholder for the OutErrTester kind of stuff. Whatever that object is
that's getting passed around. OutErrManager maybe. Wierd, could even provide overloaded versions. Wait, I could do that
anyway. Just add it at the end later, and make.., no because then it would have to be final.
OutputManager, OutputTester. Those seem nicer. Anyway, it is for another day.

Someone complained that if they configured the graphic reporter, that it should show that configuration by default not
just runs and failures. Not sure.

Do more testing on the FilterReporter config stuff.

Try sorting the GUI reports with the ordinal

I think I want to deprecate the use of -x for tags to exclude, to use it for XML Reporter. So in 0.9.6, -x should
still work, but so will some new one. And I'll warn folks that probably in 0.9.7, -x will start meaning xml reporter.

Refactor SuiteRerunner to just create a tools.SuiteRunner and call run on that. Maybe SuiteRunner should be in org.scalatest,
because it is also used by Distributor and will be used by SuiteRerunner.

add a RandomTestOrder trait

put goodies in ant task as well as properties for two releases, then drop properties
Change description of includes --> tagsToInclude,
excludes --> tagsToExclude. Leave old one in for two releases.

Add the things for Property based testing displaying args nicely in the GUI (like empty strings should be "")

The eating error message problem. Make sure an exception message shows up in the GUI/Print output.

I'm not printing out the message in a formatted report, just the exception's detail message

Do an XML reporter and an HTML reporter

Make everything private in ScalaTestTask that can be private. I see a few things that are public I think unnecessarily.

The enter-after-be issue:
love the scala-test BDD-DSL (only weird thing was a false possitive 
when I added an enter after a "be" 
be 
( 
instead of 
be ( 
The first case always passes :/ It would be better if it always failed. 


Ask folks about run versus execute
Ask folks about TestCase/Suite compatibility (check about testNames, because if that doesn't work it really is a non-starter)
Ask folks about the beforeAll and afterAll in BeforeAndAfter
Ask folks about JUnit error instead of failures being fired

a *** file-system separator separated runpath (platform-runpath)
b
c - concurrent execution (--concurrent)
d
e - standard error reporter (--stderr-reporter)
f - file reporter
g - graphical reporter
h *** HTML Reporter
i
j *** some way to run existing Java JUnit tests from command line
k
l
m - members only path
n - tags to include
o - standard out reporter
p - space-separated runpath
q
r - custom reporter
s - suite class name
t - testNG XML config file
u
v *** xml reporter (v for verbose!)
w - wildcard path
x - tags to exclude
y
z

D - goodie pair

For HTML reporter, can pick a style sheet? Could be -hC for Colorful, else get pretty one like cobertura

-w and -m could take an option "Q" for quick discovery that uses naming conventions. It would only load
classes whose .class file names end in Spec or Suite.

George list:

1. Update build.xml. Right now compile and test only builds and tests
ShouldMatchers. You have to run gencode by hand and then recompile and
test to get MustMatchers, because MustMatchers is generated from
ShouldMatchers. Please modify the ant file so default task builds all
(test builds and tests all, compile compiles all, including the
MustMatchers). Then add a qbuild and qcompile that skips the gencode
so I can do quicker builds. It takes 5 minutes to do a full build
without MustMatchers, so that's long enough. Also, if it will work,
can you make a clean target that doesn't delete the matcher tests,
because that's what takes forever to compile. Maybe a qclean?

2. Modify ant task
- Add goodies to the ant task (leaving in properties as "deprecated"
for two releases) I renamed properties to goodies because there are
two other things called properties in ScalaTest (HavePropertyMatchers
and ScalaCheck property checks). Also, one guy thought properties
specified that way should be Java system properties. Calling them
goodies should avoid that confusion as well.
- Add tagsToInclude to the ant task (leaving in includes as
"deprecated" for two releases), to bring ant task in line with new
name.
- Add tagsToExclude to the ant task (leaving in excludes as
"deprecated" for two releases), to bring ant task in line with new
name.
- Add a -a runpath command line option, (also in the ant task but I'm
not sure under what name). Idea is that -p takes a space-separated
runpath, which works fine except when people have spaces in their
paths. I want to keep -p as is, because you can specify jar files with
URLs in there, but also provide another way to specify the runpath -s,
that uses the traditional path separated by platform-specific
separator character. (On Unix, a :, on Windows, a;, etc.) Please
suggest a name for this, maybe platformRunpath or something.
- Create a JUnitWrapperSuite, which can wrap an existing set of JUnit
tests, probably written in Java, but already compiled to binary
- Recommend something to do with -j. What I'd like people to be able
to do is use -j to point ScalaTest's Runner to some existing JUnit
tests, and have it create the JUnitWrapperSuite necessary to run them
from within ScalaTest.
- The JUnit Ant task does some discovery. I think it relies on things
being named Test. I'd like to be able to tell people they can do the
exact same discovery of JUnit tests with ScalaTest's ant task as they
can with JUnit's ant task. That way it is a migration path forward.
They should be able to run those old JUnit tests with similar stuff in
the ScalaTest ant task that they now put in the JUnit ant task.
- Add a "quick" option for suite discovery. Suite discovery takes a
long time already for ScalaTest testing itself, because Scala
generates so many darn class files. We're opening every single one
looking for suites. I think if they add a Q to their -w or -m's, like
-wQ or -mQ, then that batch should be done based on naming convention.
ScalaTest will only even open class files that end in either "Spec" or
"Suite" looking for classes that extend org.scalatest.Suite. We could
add Test in there if people request it, but frankly these classes
represent suites of tests not single tests usually, so I'd like to try
and get them out of the JUnit habit of calling the classes XTest. Plus
it helps differentiate when discovering in packages that have mixed
JUnit tests and ScalaTest Suites, which would speed up both kinds of
discovery.

3. Surefire support.
- Maven uses something called SureFire to run tests. A fellow named
Jan has started some integration here. Once you get to this point, let
me know and I'll find out where Jan is at so you can see if you want
to start there. I don't know much about SureFire, but I think we need
to support Maven as well as Ant to get Maven people to use ScalaTest.

4. HTML and XML reporters
- Dianne is doing an HTML reporter, so when you get to this one, let
me know and I'll see where she's at. But one thing is we want a -h
command line param to run the HTML reporter, and also add this to the
ant task.
- Do an XML reporter that always prints out everything no matter what
it is configured with. Print out the ordinal and everything. The
reason is this can be used as an output during concurrent tests which
can be read in and then sorted to produce other output.

implicit def stackFixture = stackWithOneItem
it should behave like nonEmptyStack(lastValuePushed)
it should behave like nonFullStack

"A Stack (with one item)" should behave like nonEmptyStack(lastValuePushed)(stackWithOneItem)
it should behave like nonFullStack(stackWithOneItem)

My thought was that it should behave like could be supported in SharedTests as is.
So behave is defined in SharedTests, which requires TestRegistration as its self type. behave
is a val that refers to a BehaveWord instance.

Then in ShouldMatchers, there's the StringShouldWrapper has a should method that takes a BehaveWord 
type, but there's no instance in ShouldMatchers. So you can only use it when SharedTests's
is mixed in. And what it will need to do is register the left string as a describer. That's
all that's needed here.

"A Stack" ++ {
  "(with one item)" should {
    implicit def stackFixture = stackWithOneItem
    behave like nonEmptyStack(lastValuePushed)
    behave like nonFullStack
  }
}

In FlatSpec, just support "it should behave like X" and if ShouldMatchers is mixed in "string should behave like X". No shared tests needed.
In Spec, just support "it should behave like X." No SharedTests mix in needed. So it("test name") will have to be an apply method on
the it object.

Now, the question is FeatureSpec and FunSuite.
include testsFor nonEmptyStack(lastValuePushed, stackWithOneItem)
include testsFor nonFullStack(stackWithOneItem)

include scenariosFor nonEmptyStack(lastValuePushed)(stackWithOneItem)
include scenariosFor nonFullStack(stackWithOneItem)

That's simple and readable. Can drop SharedTests trait and TestRegistration.

ask about sugar forms for shouldEqual and mustEqual to Should/MustMatchers:

    stack.peek mustEqual lastItemAdded
    stack.size mustEqual size
    
    stack.peek shouldEqual lastItemAdded
    stack.size shouldEqual size
    
    stack.peek must_== lastItemAdded
    stack.size must_== size
    
    stack.peek should_== lastItemAdded
    stack.size should_== size

Put these into ShouldEqual and MustEqual traits, which Should/MustMatchers mix in. So that way people can get
them by themselves if they want? Or maybe not. Just add them to the Matchers traits.
    
0.9.7
Do the parallel afterAll thing.
Add BeforeAndAfterEach, BeforeAndAfterAll. Make BeforeAndAfter just an extension of BeforeAndAfterEach and BeforeAndAfterAll and deprecate it.
BeforeAndAfterAll will need to look for some object sent down in goodies from OneInstancePerTest, so it knows not to do it if it is an
"isolated test instance" or something. And then it will also have to turn off the distributor. This would mean that DistributedTestExecution
would not happen if there's an AfterAll right now. Later, what I could do is BeforeAndAfterAll wraps the distributor, if it is defined, in
an AfterAllDistributor. And that guy would wrap the suites that are put into it in a SuiteWrapper that forwards the run invocation but when
it completes (in a finally) it notifies an AfterAllActor. This react actor knows which notifications to wait for, and when they are all done, it
executes the after all method. So my theory is that since I'm using react, these actors won't hold up threads. But what tangled complexity we weave when
we first learn to parallelize.

Don't do the OneArgXXX traits

